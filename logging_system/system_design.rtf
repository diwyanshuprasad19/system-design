{\rtf1\ansi\ansicpg1252\cocoartf2759
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fmodern\fcharset0 Courier;\f2\froman\fcharset0 Times-Roman;
\f3\froman\fcharset0 Times-Bold;\f4\fnil\fcharset0 HelveticaNeue;\f5\fmodern\fcharset0 Courier-Bold;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red109\green109\blue109;\red0\green0\blue0;
\red179\green179\blue179;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c50196\c50196\c50196;\cssrgb\c0\c0\c0\c84706;
\cssrgb\c75294\c75294\c75294;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 https://docs.google.com/document/d/13tWDgafXIJbmAdgbmw-WaM7E6mcPoZMGh5NLsTLTjE4/edit?tab=t.0\
\
For any query\
\
\
Code full:\
\pard\pardeftab720\partightenfactor0

\f1\fs26 \cf0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 #include <bits/stdc++.h>\
#include <ctime> // For time_t, time, and ctime\
using namespace std;\
\
// LogLevel enumeration\
enum class LogLevel \{ DEBUG, INFO, WARNING, ERROR, FATAL \};\
\
// LogMessage class\
class LogMessage \{\
public:\
    LogMessage(LogLevel level, const string& message)\
        : level(level), message(message), timestamp(time(nullptr)) \{\} // Use time(nullptr) to get the current time\
\
    LogLevel getLevel() const \{ return level; \}\
    const string& getMessage() const \{ return message; \}\
    time_t getTimestamp() const \{ return timestamp; \}\
\
    string toString() const \{\
        stringstream ss;\
        ss << "[" << logLevelToString(level) << "] " << ctime(&timestamp) << " - " << message; // Convert time_t to string\
        return ss.str();\
    \}\
\
private:\
    LogLevel level;\
    string message;\
    time_t timestamp;\
\
    static string logLevelToString(LogLevel level) \{\
        switch (level) \{\
            case LogLevel::DEBUG: return "DEBUG";\
            case LogLevel::INFO: return "INFO";\
            case LogLevel::WARNING: return "WARNING";\
            case LogLevel::ERROR: return "ERROR";\
            case LogLevel::FATAL: return "FATAL";\
        \}\
        return "UNKNOWN";\
    \}\
\};\
\
// LogAppender base class with Chain of Responsibility\
class LogAppender \{\
protected:\
    shared_ptr<LogAppender> nextAppender;\
\
public:\
    void setNextAppender(shared_ptr<LogAppender> next) \{\
        nextAppender = next;\
    \}\
\
    virtual void append(const LogMessage& logMessage) \{\
        if (nextAppender) \{\
            nextAppender->append(logMessage);\
        \}\
    \}\
\
    virtual ~LogAppender() = default;\
\};\
\
// ConsoleAppender class\
class ConsoleAppender : public LogAppender \{\
public:\
    void append(const LogMessage& logMessage) override \{\
        cout << logMessage.toString();\
        if (nextAppender) \{\
            nextAppender->append(logMessage);\
        \}\
    \}\
\};\
\
// FileAppender class\
class FileAppender : public LogAppender \{\
private:\
    string filePath;\
\
public:\
    explicit FileAppender(const string& filePath) : filePath(filePath) \{\}\
\
    void append(const LogMessage& logMessage) override \{\
        ofstream file(filePath, ios::app);\
        if (file.is_open()) \{\
            file << logMessage.toString();\
            file.close();\
        \} else \{\
            cerr << "Failed to open log file: " << filePath << endl;\
        \}\
        if (nextAppender) \{\
            nextAppender->append(logMessage);\
        \}\
    \}\
\};\
\
// Logger class\
class Logger \{\
private:\
    LogLevel logLevel;\
    shared_ptr<LogAppender> rootAppender;\
\
    Logger() : logLevel(LogLevel::INFO), rootAppender(make_shared<ConsoleAppender>()) \{\}\
\
public:\
    static Logger& getInstance() \{\
        static Logger instance;\
        return instance;\
    \}\
\
    void setLogLevel(LogLevel level) \{\
        logLevel = level;\
    \}\
\
    void setRootAppender(shared_ptr<LogAppender> appender) \{\
        rootAppender = appender;\
    \}\
\
    void log(LogLevel level, const string& message) \{\
        if (static_cast<int>(level) >= static_cast<int>(logLevel)) \{\
            LogMessage logMessage(level, message);\
            rootAppender->append(logMessage);\
        \}\
    \}\
\
    void debug(const string& message) \{ log(LogLevel::DEBUG, message); \}\
    void info(const string& message) \{ log(LogLevel::INFO, message); \}\
    void warning(const string& message) \{ log(LogLevel::WARNING, message); \}\
    void error(const string& message) \{ log(LogLevel::ERROR, message); \}\
    void fatal(const string& message) \{ log(LogLevel::FATAL, message); \}\
\};\
\
// Main function demonstrating the chain of responsibility\
int main() \{\
    Logger& logger = Logger::getInstance();\
\
    // Create appenders\
    auto consoleAppender = make_shared<ConsoleAppender>();\
    auto fileAppender = make_shared<FileAppender>("app.log");\
\
    // Set up chain of responsibility\
    consoleAppender->setNextAppender(fileAppender);\
\
    // Configure logger\
    logger.setRootAppender(consoleAppender);\
\
    // Example 1: Default log level is INFO, logLevel = INFO\
    cout << "Logging messages at INFO level:\\n";\
    logger.setLogLevel(LogLevel::INFO);\
    logger.debug("This debug message won't appear (log level is INFO).");\
    logger.info("An informational message.");\
    logger.warning("A warning message.");\
    logger.error("An error message.");\
    logger.fatal("A fatal message.\\n");\
\
    // Example 2: Set log level to DEBUG, logLevel = DEBUG\
    cout << "\\nLogging messages at DEBUG level:\\n";\
    logger.setLogLevel(LogLevel::DEBUG);\
    logger.debug("A debug message.");\
    logger.info("Another informational message.");\
    logger.warning("Another warning message.");\
    logger.error("Another error message.");\
    logger.fatal("Another fatal message.\\n");\
\
    // Check the app.log file for messages as well!\
\
    return 0;\
\}\
\pard\pardeftab720\partightenfactor0

\f2\fs24 \cf3 \strokec3 \
\pard\pardeftab720\sa280\partightenfactor0

\f3\b\fs28 \cf0 \strokec2 Expected Output\
\pard\pardeftab720\sa319\partightenfactor0

\fs24 \cf0 Console Output\
\pard\pardeftab720\sa240\partightenfactor0

\f2\b0 \cf0 When running the program, you'll see the following output in the console:\
\pard\pardeftab720\partightenfactor0

\f1\fs26 \cf0 less\
\pard\pardeftab720\partightenfactor0

\f4\fs22 \cf4 \cb5 \strokec4 Copy code
\f1\fs26 \cf0 \cb1 \strokec2 \
Logging messages at INFO level:\
[INFO] Thu Dec 18 10:25:00 2024 - An informational message.\
[WARNING] Thu Dec 18 10:25:00 2024 - A warning message.\
[ERROR] Thu Dec 18 10:25:00 2024 - An error message.\
[FATAL] Thu Dec 18 10:25:00 2024 - A fatal message.\
\
Logging messages at DEBUG level:\
[DEBUG] Thu Dec 18 10:25:01 2024 - A debug message.\
[INFO] Thu Dec 18 10:25:01 2024 - Another informational message.\
[WARNING] Thu Dec 18 10:25:01 2024 - Another warning message.\
[ERROR] Thu Dec 18 10:25:01 2024 - Another error message.\
[FATAL] Thu Dec 18 10:25:01 2024 - Another fatal message.\
\pard\pardeftab720\partightenfactor0

\f2\fs24 \cf3 \strokec3 \
\pard\pardeftab720\sa319\partightenfactor0

\f3\b \cf0 \strokec2 File Output (
\f5\fs26 app.log
\f3\fs24 )\
\pard\pardeftab720\sa240\partightenfactor0

\f2\b0 \cf0 The 
\f1\fs26 app.log
\f2\fs24  file will have the same content as the console output because the 
\f1\fs26 ConsoleAppender
\f2\fs24  is chained to the 
\f1\fs26 FileAppender
\f2\fs24 .\
}