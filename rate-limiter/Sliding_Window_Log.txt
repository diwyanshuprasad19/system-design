What is Sliding Window Log?
It keeps a log of timestamps for each request.
When a new request arrives:

The system removes outdated timestamps (outside the current window, e.g., 1 minute).

Then it checks the count of timestamps remaining.

If the number is below the limit â†’ âœ… allow

Else â†’ âŒ deny

ğŸ§  Layman Explanation
Imagine a guest logbook for your house.
You only allow 5 guests per hour.
Each time someone visits, you write their time in the logbook.
Before letting the next guest in, you:

Remove entries older than 1 hour.

Count remaining guests.

If fewer than 5 â†’ let the guest in.

ğŸ“ˆ Real-Time Example
Time	Action	Log	Result
1:00:01	Request 1 â†’ âœ…	[1:00:01]	âœ…
1:00:30	Request 2 â†’ âœ…	[1:00:01, 1:00:30]	âœ…
1:00:50	Request 3 â†’ âŒ	[1:00:01, 1:00:30, 1:00:50]	âŒ
1:01:40	Request 4 â†’ âœ…	[1:00:50, 1:01:40] (others expired)	âœ…
âœ… C++ Implementation (Simplified, Non-Threaded)
cpp
Copy
Edit
#include <bits/stdc++.h>
#include <chrono>
#include <thread>
using namespace std;

class SlidingWindowLogRateLimiter {
private:
    int requestLimit;
    int windowSeconds;
    deque<long long> requestTimestamps;

    long long getCurrentTimeSeconds() {
        auto now = chrono::system_clock::now();
        auto duration = chrono::duration_cast<chrono::seconds>(now.time_since_epoch());
        return duration.count();  // current time in seconds
    }

public:
    SlidingWindowLogRateLimiter(int limit, int windowInSeconds)
        : requestLimit(limit), windowSeconds(windowInSeconds) {}

    bool tryProcessRequest() {
        long long now = getCurrentTimeSeconds();

        // Remove outdated timestamps
        while (!requestTimestamps.empty() && now - requestTimestamps.front() > windowSeconds) {
            requestTimestamps.pop_front();
        }

        if (requestTimestamps.size() < requestLimit) {
            requestTimestamps.push_back(now);
            return true;
        }

        return false;
    }
};

int main() {
    SlidingWindowLogRateLimiter limiter(5, 60); // 5 requests per 60 seconds

    for (int i = 1; i <= 10; i++) {
        bool allowed = limiter.tryProcessRequest();
        cout << "Request " << i << ": " << (allowed ? "Allowed âœ…" : "Blocked âŒ") << endl;
        this_thread::sleep_for(chrono::seconds(10)); // Simulate 10s delay
    }

    return 0;
}
ğŸ§ª Output
yaml
Copy
Edit
Request 1: Allowed âœ…
Request 2: Allowed âœ…
Request 3: Allowed âœ…
Request 4: Allowed âœ…
Request 5: Allowed âœ…
Request 6: Blocked âŒ
Request 7: Blocked âŒ
...
Request 10: Allowed âœ… (after old ones expire)
âœ… Why Use Sliding Window Log?
Feature	Value
Accuracy	âœ… Best among all limiters
Allows smooth traffic	âœ… Yes
Memory usage	âŒ Slightly higher (stores each request)
Use case	âœ… Real-time strict limits (e.g., login, payments)
ğŸ§  Summary: Sliding Window Log vs Others
Feature	Token Bucket	Leaky Bucket	Fixed Window	Sliding Log
Bursty traffic okay?	âœ…	âŒ	âš ï¸ Yes (edge burst)	âœ…
Per-request memory?	âŒ	âŒ	âŒ	âœ… (log)
Most accurate?	âŒ	âœ…	âŒ	âœ…
Production safe?	âœ…	âœ…	âŒ	âœ…
