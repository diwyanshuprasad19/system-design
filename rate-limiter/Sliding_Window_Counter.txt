What Is Sliding Window Counter?
A rate limiting algorithm that splits a time window (like 1 hour) into multiple smaller buckets (like 60 1-min blocks).
It then:

Stores counts (not timestamps!) per bucket

When a request comes, it adds up the counts from the relevant buckets (like last 60 mins)

If total < limit â†’ âœ… allow

Otherwise â†’ âŒ deny

ðŸ§  Layman Explanation
Imagine a whiteboard with 60 boxes, each for a minute in the past hour.
Every time someone makes a request:

You put a tally mark in the current box.

When the clock ticks, you shift focus to the next box.

The algorithm adds all 60 boxes â†’ decides whether to allow another request.

ðŸ“ˆ Visualization
sql
Copy
Edit
Current Time: 2:50 PM
Sliding Window: 2:50 â†’ 3:50
1-Min Buckets:
  [2:50-2:51] = 5
  [2:49-2:50] = 3
  [2:48-2:49] = 0
  ...
  Total in last hour = 60 â†’ âœ… Request allowed
ðŸ§ª Real-Time Use Case:
Limit: 100 requests/hour

Sub-window (bucket): 1 minute

Per-minute limit: 5 requests

ðŸ’» Efficient C++ Implementation (Sliding Window Counter)
cpp
Copy
Edit
#include <bits/stdc++.h>
#include <chrono>
#include <thread>
using namespace std;

class SlidingWindowCounter {
private:
    int hourlyLimit;
    int perMinuteLimit;
    int windowSizeMinutes;
    unordered_map<long long, int> buckets;

    long long getCurrentMinute() {
        auto now = chrono::system_clock::now();
        return chrono::duration_cast<chrono::minutes>(now.time_since_epoch()).count();
    }

public:
    SlidingWindowCounter(int hourly, int perMin)
        : hourlyLimit(hourly), perMinuteLimit(perMin), windowSizeMinutes(60) {}

    bool tryProcessRequest() {
        long long nowMinute = getCurrentMinute();

        // Remove buckets older than 60 mins
        for (auto it = buckets.begin(); it != buckets.end();) {
            if (nowMinute - it->first >= windowSizeMinutes)
                it = buckets.erase(it);
            else
                ++it;
        }

        // Sum over all buckets in last 60 minutes
        int totalRequests = 0;
        for (auto& [minute, count] : buckets)
            totalRequests += count;

        if (totalRequests >= hourlyLimit)
            return false;

        // Check this minuteâ€™s bucket
        if (buckets[nowMinute] >= perMinuteLimit)
            return false;

        buckets[nowMinute]++;
        return true;
    }
};

int main() {
    SlidingWindowCounter limiter(100, 5); // 100 req/hour, 5 req/min

    for (int i = 1; i <= 120; i++) {
        bool allowed = limiter.tryProcessRequest();
        cout << "Request " << i << ": " << (allowed ? "Allowed âœ…" : "Blocked âŒ") << endl;
        this_thread::sleep_for(chrono::milliseconds(500)); // 0.5 sec delay
    }

    return 0;
}
âœ… Sample Output (Partial)
yaml
Copy
Edit
Request 1: Allowed âœ…
Request 2: Allowed âœ…
Request 3: Allowed âœ…
Request 4: Allowed âœ…
Request 5: Allowed âœ…
Request 6: Blocked âŒ
...
Request 13: Allowed âœ… (after moving into new minute bucket)
âš™ï¸ Efficiency Benefits
Factor	Sliding Window Log	Sliding Window Counter
Stores each request	âœ… Yes	âŒ No
Stores per-minute count	âŒ No	âœ… Yes
Memory usage	High	Low
Ideal for production?	âš ï¸ Limited	âœ… Yes
ðŸ§  Summary
Feature	Value
Accurate under scale	âœ… Yes
Low memory usage	âœ… Yes (buckets, not full logs)
Sliding precision	âœ… Yes (vs. fixed window edge burst)
Ideal use case	APIs, auth, per-user request caps



Sliding Window Log vs Sliding Window Counter
Metric	Sliding Window Log	Sliding Window Counter
What it stores	â±ï¸ Individual timestamps of each request	ðŸ§® Aggregated count per time bucket (e.g., per minute)
Time complexity	O(n) per request (removing outdated timestamps)	O(1) per request (just increment & sum)
Space complexity	O(n) â€” stores every request individually	O(k) â€” only stores k buckets (e.g., 60 for hour)
Precision	âœ… Very precise (to the second)	âš–ï¸ Slightly approximate (per bucket granularity)
CPU usage	ðŸ”¥ Higher at scale	ðŸ§Š Lower, predictable
Memory usage	âŒ Increases with traffic	âœ… Constant space (fixed # of buckets)
Ideal for	Few users, high precision	High concurrency, production-scale systems
ðŸ§  In Simple Terms
ðŸ”¹ Sliding Window Log
Acts like a scroll of paper:
Write the exact time of every request

To decide if the next request is allowed:

You scan and clean the log (remove expired timestamps)

Count how many requests remain

âœ… High precision, âŒ High work per request

ðŸ§ª Time complexity: O(n)
ðŸ§ª Space complexity: O(n)
(n = number of requests in the window)

ðŸ”¹ Sliding Window Counter
Acts like a whiteboard with 60 boxes

Each box is 1 minute

You only track how many requests in each minute

On a new request:

You clean only old buckets (e.g., anything older than 60 min)

Just sum 60 values

ðŸ§ª Time complexity: O(1) to update and check
ðŸ§ª Space complexity: O(k)
(k = number of buckets, e.g., 60 for an hour)

ðŸ§ª Real-World Example
Letâ€™s say:

Your API gets 1 million requests per minute

You want to allow 1000 req/hour per user

With Log (per user)	With Counter (per user)
Store 1000 timestamps	Store 60 integer values
On each request: loop + count	Just sum 60 buckets
CPU = ðŸ”¥	CPU = ðŸ§Š
Now imagine 100K users concurrently â†’
Log system blows up ðŸ’£
Counter system runs smooth âœ…

âœ… TL;DR Summary
Feature	Sliding Window Log	Sliding Window Counter (âœ” better)
Precision	â±ï¸ To the second	ðŸ§® To the bucket (e.g., 1 min)
Memory cost per user	âŒ Unbounded	âœ… Fixed (e.g., 60 ints per user)
Time to evaluate per request	âŒ O(n)	âœ… O(1)
Performance at scale	âŒ Poor for 100K users	âœ… Efficient
Suitable for high-throughput	âŒ No	âœ… Yes
ðŸŽ¯ When to Use Each?
Use Case	Recommendation
Low traffic, high accuracy needed	Use Sliding Log
Massive scale, real-time APIs	Use Sliding Counter âœ…
Precise fraud detection (banking)	Maybe Log
Chat, search, message rate limits	Use Counter âœ…
