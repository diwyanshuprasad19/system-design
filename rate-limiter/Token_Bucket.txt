Token Bucket Rate Limiting â€“ Full Guide (C++ Non-Threaded Version)
ğŸ” What is Token Bucket?
A rate limiting algorithm that uses a "bucket of tokens" to control the number of requests a system will allow in a given time window.

ğŸ§  Layman Explanation
Imagine a bucket that fills with tokens, one token per second.

Each request takes 1 token from the bucket.

If the bucket is empty, the request is denied.

If you donâ€™t make any requests for a while, tokens accumulate (up to a max).

Allows short bursts, but limits sustained overuse.

ğŸ“ˆ Visual Diagram
sql
Copy
Edit
        +-----------------------------+
        |       Token Generator       |
        |  (1 token per second)       |
        +--------------+--------------+
                       |
             +---------v----------+
             |   TOKEN BUCKET     | â† Max = 3 tokens
             +---------+----------+
                       |
           +-----------v-----------+
           |     TryConsume()      |
           |  if token exists â†’ âœ… |
           |  else â†’ HTTP 429 âŒ   |
           +-----------------------+
ğŸ§ª Real-Time Scenario
You allow a user to send 3 API requests instantly

And then 1 new request per second

Example Flow:
Time	Action	Tokens Left	Result
0 sec	Request 1	2	âœ…
0 sec	Request 2	1	âœ…
0 sec	Request 3	0	âœ…
0 sec	Request 4	0	âŒ
+1 sec	1 token added	1	
+1 sec	Request 5	0	âœ…
ğŸ’» Full Code â€“ Non-Thread-Safe Version
cpp
Copy
Edit
#include <bits/stdc++.h>
#include <chrono>
#include <thread>
using namespace std;

class TokenBucket {
private:
    double maxBucketSize;
    double refillRatePerSecond;
    double currentBucketSize;
    long long lastRefillTimestamp;

    // Get current time in milliseconds
    long long getCurrentTimeMillis() {
        return chrono::duration_cast<chrono::milliseconds>(
            chrono::system_clock::now().time_since_epoch()
        ).count();
    }

    // Refill tokens based on elapsed time
    void refill() {
        long long now = getCurrentTimeMillis();
        long long elapsed = now - lastRefillTimestamp;

        double refillAmount = (elapsed / 1000.0) * refillRatePerSecond;
        currentBucketSize = min(maxBucketSize, currentBucketSize + refillAmount);
        lastRefillTimestamp = now;
    }

public:
    TokenBucket(double maxSize, double refillRate)
        : maxBucketSize(maxSize), refillRatePerSecond(refillRate),
          currentBucketSize(maxSize) {
        lastRefillTimestamp = getCurrentTimeMillis();
    }

    // Consume token if available
    bool tryConsume(double amount) {
        refill();
        if (currentBucketSize >= amount) {
            currentBucketSize -= amount;
            return true;
        }
        return false;
    }
};

int main() {
    TokenBucket bucket(3, 1); // max 3 tokens, 1 token/sec refill

    cout << "Request 1 processed: " << bucket.tryConsume(1) << endl; // âœ…
    cout << "Request 2 processed: " << bucket.tryConsume(1) << endl; // âœ…
    cout << "Request 3 processed: " << bucket.tryConsume(1) << endl; // âœ…
    cout << "Request 4 processed: " << bucket.tryConsume(1) << endl; // âŒ

    this_thread::sleep_for(chrono::seconds(1)); // wait for refill

    cout << "Request 5 processed: " << bucket.tryConsume(1) << endl; // âœ…

    return 0;
}
âœ… Sample Output
yaml
Copy
Edit
Request 1 processed: 1
Request 2 processed: 1
Request 3 processed: 1
Request 4 processed: 0
Request 5 processed: 1
ğŸ§± Use Cases for This Version
Use Case	Is It Suitable?
Local testing & learning	âœ… Yes
CLI tools with one thread	âœ… Yes
Web apps with threading	âŒ No (use thread-safe)
Distributed services	âŒ Use Redis or DB-backed counters
